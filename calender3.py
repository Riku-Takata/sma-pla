# -*- coding: utf-8 -*-
"""calender.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jMGe6l2kRKhDxjplO8l83Bgp0X9W0QNM
"""

# Make sure to run the following command in your terminal or Jupyter notebook cell:
# !pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib


import datetime
import os
import pickle
import pytz
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import openai
import re
import json

# ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã‚’æŒ‡å®š
TZ = pytz.timezone("Asia/Tokyo")

# ãƒˆãƒ¼ã‚¯ãƒ³ã®ä¿å­˜å…ˆ
TOKEN_PATH = "token.pickle"
CREDENTIALS_FILE = "client_secret.json"

# ã‚¹ã‚³ãƒ¼ãƒ—ã‚’è¨­å®š
SCOPES = ['https://www.googleapis.com/auth/calendar']

# OpenAI API ã‚­ãƒ¼ã®è¨­å®š
# Google Colab ã§å®Ÿè¡Œã™ã‚‹å ´åˆã€ä»¥ä¸‹ã®æ–¹æ³•ã§APIã‚­ãƒ¼ã‚’è¨­å®šã§ãã¾ã™
# ç’°å¢ƒå¤‰æ•°ã‹ã‚‰èª­ã¿è¾¼ã‚€å ´åˆ:
# openai.api_key = os.environ.get("OPENAI_API_KEY")
# ã¾ãŸã¯ç›´æ¥è¨­å®šã™ã‚‹å ´åˆ:
# openai.api_key = "your-api-key-here"  # å®Ÿéš›ã®ã‚­ãƒ¼ã«ç½®ãæ›ãˆã¦ãã ã•ã„

def setup_openai_api():
    """OpenAI API ã‚­ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—"""
    if not openai.api_key:
        api_key = input("ğŸ”‘ OpenAI API ã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„: ").strip()
        openai.api_key = api_key
        # Colabã§ã¯ç’°å¢ƒå¤‰æ•°ã‚‚è¨­å®šã—ã¦ãŠãã¨ä¾¿åˆ©
        os.environ["OPENAI_API_KEY"] = api_key
    print("âœ… OpenAI API ã‚­ãƒ¼ã‚’è¨­å®šã—ã¾ã—ãŸ")


def extract_event_info(text):
    """OpenAI APIã‚’ä½¿ç”¨ã—ã¦æ–‡ç« ã‹ã‚‰äºˆå®šæƒ…å ±ã‚’æŠ½å‡ºã™ã‚‹"""
    try:
        response = openai.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": """
                ã‚ãªãŸã¯äºˆå®šæƒ…å ±ã‚’æŠ½å‡ºã™ã‚‹å°‚é–€å®¶ã§ã™ã€‚
                æ–‡ç« ã‹ã‚‰ä»¥ä¸‹ã®æƒ…å ±ã‚’æŠ½å‡ºã—ã€JSONå½¢å¼ã§è¿”ã—ã¦ãã ã•ã„:
                - summary: ã‚¤ãƒ™ãƒ³ãƒˆã®åå‰ã¾ãŸã¯ã‚¿ã‚¤ãƒˆãƒ«ã€‚æ–‡ç« ã‹ã‚‰é©åˆ‡ãªã‚¿ã‚¤ãƒˆãƒ«ã‚’æ¨æ¸¬ã—ã¦ãã ã•ã„ã€‚å¿…ãšè¨­å®šã—ã¦ãã ã•ã„ã€‚
                - date: YYYY-MM-DDå½¢å¼ã®æ—¥ä»˜
                - time: HH:MMå½¢å¼ã®é–‹å§‹æ™‚é–“
                - duration: åˆ†å˜ä½ã®ã‚¤ãƒ™ãƒ³ãƒˆæ™‚é–“
                - location: ã‚¤ãƒ™ãƒ³ãƒˆã®å ´æ‰€
                - description: ã‚¤ãƒ™ãƒ³ãƒˆã®èª¬æ˜ã‚„è©³ç´°
                - all_day: çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚° (true/false)

                æ—¥ä»˜ã‚„æ™‚é–“ãŒæ˜ç¤ºçš„ã«ç¤ºã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€æ–‡è„ˆã‹ã‚‰æ¨æ¸¬ã—ã¦ãã ã•ã„ã€‚
                ä»Šæ—¥ãƒ»æ˜æ—¥ãƒ»æ˜å¾Œæ—¥ãªã©ã®ç›¸å¯¾çš„ãªæ—¥ä»˜ã¯ã€ç¾åœ¨ã®æ—¥ä»˜ï¼ˆ""" + datetime.datetime.now(TZ).strftime("%Y-%m-%d") + """ï¼‰ã‹ã‚‰è¨ˆç®—ã—ã¦ãã ã•ã„ã€‚
                ã‚‚ã—äºˆå®šã®ç¨®é¡ãŒä¼šè­°ã€é¢è«‡ã€æ‰“ã¡åˆã‚ã›ãªã©ã§ã‚ã‚Œã°ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ‰€è¦æ™‚é–“ã¯60åˆ†ã¨è¨­å®šã—ã¦ãã ã•ã„ã€‚
                æ˜ç¢ºãªå ´æ‰€ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ã€Œã‚ªãƒ•ã‚£ã‚¹ã€ã‚„ã€Œä¼šè­°å®¤ã€ãªã©ã®å¦¥å½“ãªå ´æ‰€ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚
                çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã«é–¢ã™ã‚‹è¨€åŠãŒã‚ã‚Œã°ã€all_dayã‚’trueã«è¨­å®šã—ã¦ãã ã•ã„ã€‚
                JSONã®ã¿ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚
                """},
                {"role": "user", "content": text}
            ],
            response_format={"type": "json_object"}
        )

        # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰JSONã‚’æŠ½å‡º
        result = response.choices[0].message.content
        return result
    except Exception as e:
        print(f"âŒ OpenAI APIã‚¨ãƒ©ãƒ¼: {e}")
        return None


def analyze_user_response(response_text):
    """OpenAI APIã‚’ä½¿ç”¨ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å¿œç­”ã‚’è‚¯å®šçš„ã‹å¦å®šçš„ã‹åˆ†æã™ã‚‹"""
    try:
        response = openai.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": """
                ã‚ãªãŸã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å¿œç­”ã‚’åˆ†æã™ã‚‹å°‚é–€å®¶ã§ã™ã€‚
                ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å¿œç­”ãŒè‚¯å®šçš„ï¼ˆåŒæ„ã€æ‰¿è«¾ï¼‰ã‹å¦å®šçš„ï¼ˆæ‹’å¦ã€ä¸åŒæ„ï¼‰ã‹ã‚’åˆ¤æ–­ã—ã€JSONã§è¿”ã—ã¦ãã ã•ã„ã€‚
                ä¾‹ãˆã°ã€Œã„ã„ã‚ˆã€ã€ŒOKã€ã€Œå¤§ä¸ˆå¤«ã€ã€Œäº†è§£ã€ãªã©ã¯è‚¯å®šçš„ã€ã€Œãƒ€ãƒ¡ã€ã€Œç„¡ç†ã€ã€Œåˆ¥ã®æ—¥ãŒã„ã„ã€ãªã©ã¯å¦å®šçš„ã§ã™ã€‚
                å¿œç­”ãŒæ›–æ˜§ãªå ´åˆã¯ã€ã‚ˆã‚Šå®‰å…¨ãªã€Œå¦å®šçš„ã€ã¨åˆ¤æ–­ã—ã¦ãã ã•ã„ã€‚
                
                ä»¥ä¸‹ã®å½¢å¼ã®JSONã‚’è¿”ã—ã¦ãã ã•ã„ï¼š
                {"is_affirmative": true/false, "confidence": 0-100}
                """},
                {"role": "user", "content": f"ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å¿œç­”: {response_text}"}
            ],
            response_format={"type": "json_object"}
        )
        
        result = json.loads(response.choices[0].message.content)
        return result
    except Exception as e:
        print(f"âŒ OpenAI å¿œç­”åˆ†æã‚¨ãƒ©ãƒ¼: {e}")
        # ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯å®‰å…¨ã®ãŸã‚å¦å®šçš„ã¨åˆ¤æ–­
        return {"is_affirmative": False, "confidence": 0}


def get_calendar_service():
    """Google ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ API ã®èªè¨¼ã‚’å‡¦ç†"""
    creds = None

    if os.path.exists(TOKEN_PATH):
        with open(TOKEN_PATH, 'rb') as token:
            creds = pickle.load(token)

    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            try:
                creds.refresh(Request())
            except Exception as e:
                print(f"ğŸ”„ ãƒˆãƒ¼ã‚¯ãƒ³ã®ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã«å¤±æ•—: {e}")
                creds = None

        if not creds:
            flow = InstalledAppFlow.from_client_secrets_file(CREDENTIALS_FILE, SCOPES)
            flow.redirect_uri = "urn:ietf:wg:oauth:2.0:oob"

            auth_url, _ = flow.authorization_url(prompt='consent')
            print(f"\nğŸ”— ä»¥ä¸‹ã®URLã‚’é–‹ã„ã¦èªè¨¼ã—ã¦ãã ã•ã„:\n{auth_url}")

            code = input("ğŸ‘‰ èªè¨¼å¾Œã«è¡¨ç¤ºã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„: ").strip()
            flow.fetch_token(code=code)
            creds = flow.credentials

        with open(TOKEN_PATH, 'wb') as token:
            pickle.dump(creds, token)

    return build('calendar', 'v3', credentials=creds)


def parse_event_time(event_time):
    """Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼APIã®ã‚¤ãƒ™ãƒ³ãƒˆæ™‚åˆ»ã‚’æ­£ã—ãè§£æï¼ˆçµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆå¯¾å¿œï¼‰"""
    if 'dateTime' in event_time:
        return datetime.datetime.fromisoformat(event_time['dateTime']).astimezone(TZ)
    elif 'date' in event_time:
        # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã€é–‹å§‹æ™‚åˆ»ã¯æŒ‡å®šæ—¥ã®0æ™‚ã€çµ‚äº†æ™‚åˆ»ã¯ç¿Œæ—¥ã®0æ™‚
        date_obj = datetime.datetime.strptime(event_time['date'], "%Y-%m-%d")
        return TZ.localize(date_obj)
    return None


def check_all_day_event_conflict(all_day_events, start_time, end_time):
    """çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã¨æŒ‡å®šã—ãŸæ™‚é–“å¸¯ãŒé‡è¤‡ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯"""
    conflicts = []

    # é–‹å§‹æ—¥ã¨çµ‚äº†æ—¥ã‚’æ—¥ä»˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦å–å¾—
    start_date = start_time.date()
    end_date = end_time.date()

    for event in all_day_events:
        event_start = parse_event_time(event['start'])
        event_end = parse_event_time(event['end'])

        if event_start and event_end:
            event_start_date = event_start.date()
            # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã®çµ‚äº†æ—¥ã¯é€šå¸¸ã€æ¬¡ã®æ—¥ã‚’æŒ‡ã™ãŸã‚1æ—¥å¼•ã
            event_end_date = (event_end - datetime.timedelta(days=1)).date()

            # äºˆå®šãŒé‡è¤‡ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            if max(start_date, event_start_date) <= min(end_date, event_end_date):
                conflicts.append((event.get('summary', 'ï¼ˆç„¡é¡Œã®äºˆå®šï¼‰'), event_start, event_end, event))

    return conflicts


def find_conflicting_events(service, start_time, end_time):
    """æŒ‡å®šã—ãŸæ™‚é–“å¸¯ã«é‡è¤‡ã™ã‚‹äºˆå®šã‚’æ¤œç´¢ï¼ˆçµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆå¯¾å¿œï¼‰"""
    # é€šå¸¸ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ¤œç´¢
    events_result = service.events().list(
        calendarId='primary',
        timeMin=start_time.astimezone(pytz.UTC).isoformat(),
        timeMax=end_time.astimezone(pytz.UTC).isoformat(),
        singleEvents=True,
        orderBy='startTime'
    ).execute()

    events = events_result.get('items', [])
    conflicts = []
    all_day_conflicts = []

    # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã¨é€šå¸¸ã‚¤ãƒ™ãƒ³ãƒˆã‚’åˆ†é›¢
    all_day_events = []
    regular_events = []

    for event in events:
        if 'date' in event.get('start', {}):
            all_day_events.append(event)
        else:
            regular_events.append(event)

    # é€šå¸¸ã‚¤ãƒ™ãƒ³ãƒˆã¨ã®é‡è¤‡ã‚’ãƒã‚§ãƒƒã‚¯
    for event in regular_events:
        event_start = parse_event_time(event['start'])
        event_end = parse_event_time(event['end'])
        event_title = event.get('summary', 'ï¼ˆç„¡é¡Œã®äºˆå®šï¼‰')

        # äºˆå®šãŒé‡è¤‡ã—ã¦ã„ã‚‹å ´åˆ
        if event_start and event_end and (
            (start_time < event_end and start_time >= event_start) or
            (end_time > event_start and end_time <= event_end) or
            (start_time <= event_start and end_time >= event_end)
        ):
            conflicts.append((event_title, event_start, event_end, event))

    # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã¨ã®é‡è¤‡ã‚’ãƒã‚§ãƒƒã‚¯
    all_day_conflicts = check_all_day_event_conflict(all_day_events, start_time, end_time)

    return conflicts, all_day_conflicts


def find_next_available_time(service, start_time, duration_minutes, max_days=7):
    """æ¬¡ã«ç©ºã„ã¦ã„ã‚‹æ™‚é–“ã‚’æ¢ã™ï¼ˆè¤‡æ•°æ—¥ã«ã‚ãŸã£ã¦æ¤œç´¢ï¼‰"""
    current_day = start_time.replace(hour=9, minute=0)  # å½“æ—¥ã®å‹¤å‹™é–‹å§‹æ™‚é–“
    end_search = start_time + datetime.timedelta(days=max_days)  # æœ€å¤§ã§1é€±é–“å…ˆã¾ã§æ¤œç´¢

    while current_day < end_search:
        # ä¸€æ—¥ã®å‹¤å‹™æ™‚é–“ã‚’9:00-18:00ã¨ã™ã‚‹
        day_start = current_day
        day_end = current_day.replace(hour=18, minute=0)

        # ç¾åœ¨ã®æ—¥ã®äºˆå®šã‚’å–å¾—
        events_result = service.events().list(
            calendarId='primary',
            timeMin=day_start.astimezone(pytz.UTC).isoformat(),
            timeMax=day_end.astimezone(pytz.UTC).isoformat(),
            singleEvents=True,
            orderBy='startTime'
        ).execute()

        events = events_result.get('items', [])

        # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã‚’å–å¾—
        all_day_events = []
        for event in events:
            if 'date' in event.get('start', {}):
                all_day_events.append(event)

        # ã“ã®æ—¥ãŒçµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã§åŸ‹ã¾ã£ã¦ã„ã‚‹å ´åˆã¯æ¬¡ã®æ—¥ã¸
        all_day_conflicts = check_all_day_event_conflict(all_day_events, day_start, day_end)
        if all_day_conflicts and len(all_day_conflicts) > 0:
            current_day = (current_day + datetime.timedelta(days=1)).replace(hour=9, minute=0)
            continue

        # é€šå¸¸ã‚¤ãƒ™ãƒ³ãƒˆã‚’æ™‚é–“é †ã«ã‚½ãƒ¼ãƒˆ
        regular_events = [e for e in events if 'dateTime' in e.get('start', {})]
        regular_events.sort(key=lambda x: parse_event_time(x['start']))

        # ç©ºãæ™‚é–“ã‚’æ¢ã™
        current_time = max(day_start, start_time) if current_day.date() == start_time.date() else day_start

        # å„ã‚¤ãƒ™ãƒ³ãƒˆé–“ã®ç©ºãæ™‚é–“ã‚’ãƒã‚§ãƒƒã‚¯
        for event in regular_events:
            event_start = parse_event_time(event['start'])
            event_end = parse_event_time(event['end'])

            if event_start and event_end:
                # ç¾åœ¨æ™‚é–“ã‹ã‚‰ã‚¤ãƒ™ãƒ³ãƒˆé–‹å§‹ã¾ã§ã«ååˆ†ãªç©ºããŒã‚ã‚‹ã‹
                if (event_start - current_time).total_seconds() / 60 >= duration_minutes:
                    return current_time

                # æ¬¡ã®ãƒã‚§ãƒƒã‚¯æ™‚é–“ã‚’ã‚¤ãƒ™ãƒ³ãƒˆçµ‚äº†å¾Œã«è¨­å®š
                current_time = max(current_time, event_end)

        # æœ€å¾Œã®ã‚¤ãƒ™ãƒ³ãƒˆå¾Œã«æ™‚é–“ãŒæ®‹ã£ã¦ã„ã‚‹ã‹
        if (day_end - current_time).total_seconds() / 60 >= duration_minutes:
            return current_time

        # æ¬¡ã®æ—¥ã®å‹¤å‹™é–‹å§‹æ™‚é–“ã«è¨­å®š
        current_day = (current_day + datetime.timedelta(days=1)).replace(hour=9, minute=0)

    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¨ã—ã¦1é€±é–“å¾Œã®åŒã˜æ™‚é–“ã‚’è¿”ã™
    return start_time + datetime.timedelta(days=7)


# éƒ¨åˆ†çš„ãªä¿®æ­£ - add_eventãƒ¡ã‚½ãƒƒãƒ‰ã®æ”¹å–„ã•ã‚ŒãŸãƒãƒ¼ã‚¸ãƒ§ãƒ³

def add_event(service, summary, location, description, start_time, end_time, is_all_day=False):
    """ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«è¿½åŠ ã™ã‚‹ï¼ˆçµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆå¯¾å¿œï¼‰"""
    print("\nğŸ“… è¿½åŠ ã™ã‚‹äºˆå®šã®è©³ç´°:")
    print(f"  ğŸ· ã‚¿ã‚¤ãƒˆãƒ«: {summary}")
    print(f"  ğŸ“ å ´æ‰€: {location}")
    print(f"  ğŸ“ èª¬æ˜: {description}")

    if is_all_day:
        print(f"  ğŸ“† çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆ: {start_time.strftime('%Y-%m-%d')}")
    else:
        print(f"  â° é–‹å§‹: {start_time.strftime('%Y-%m-%d %H:%M')}")
        print(f"  â³ çµ‚äº†: {end_time.strftime('%Y-%m-%d %H:%M')}")

    # é‡è¤‡ã™ã‚‹äºˆå®šã‚’å–å¾—
    regular_conflicts, all_day_conflicts = find_conflicting_events(service, start_time, end_time)
    already_confirmed = False  # æ—¢ã«ç¢ºèªæ¸ˆã¿ã‹ã©ã†ã‹ã‚’è¿½è·¡ã™ã‚‹ãƒ•ãƒ©ã‚°
    schedule_changed = False   # ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå¤‰æ›´ã•ã‚ŒãŸã‹ã‚’è¿½è·¡ã™ã‚‹ãƒ•ãƒ©ã‚°

    # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã¨ã®ç«¶åˆã‚’å…ˆã«å‡¦ç†
    if all_day_conflicts:
        print("\nâš  **ã“ã®æ—¥ã«ã¯ä»¥ä¸‹ã®çµ‚æ—¥äºˆå®šãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™ï¼**")
        for title, c_start, c_end, _ in all_day_conflicts:
            print(f"  ğŸ“† {title}ï¼ˆçµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆ: {c_start.strftime('%Y-%m-%d')}ï¼‰")

        # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã¨ã®ç«¶åˆæ™‚ã®ç‰¹åˆ¥ãªãƒ•ãƒ­ãƒ¼
        choice = input("\nã“ã®çµ‚æ—¥äºˆå®šã¨é‡è¤‡ã—ã¦ã„ã¾ã™ãŒã€ãã‚Œã§ã‚‚ã“ã®äºˆå®šã‚’è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ (y/n): ").strip().lower()
        if choice == 'y':
            # ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒäº†æ‰¿ã—ãŸã®ã§ã€ãã®ã¾ã¾è¿½åŠ å‡¦ç†ã¸é€²ã‚€
            already_confirmed = True  # ç¢ºèªæ¸ˆã¿ã¨ã—ã¦ãƒãƒ¼ã‚¯
            pass
        else:
            # åˆ¥ã®æ—¥æ™‚ã‚’ææ¡ˆ
            print("\nåˆ¥ã®æ™‚é–“å¸¯ã‚’æ¢ã—ã¾ã™...")
            suggested_time = find_next_available_time(service, start_time, (end_time - start_time).seconds // 60)
            suggested_end = suggested_time + datetime.timedelta(minutes=(end_time - start_time).seconds // 60)

            # ã‚ˆã‚Šè‡ªç„¶ãªãƒªã‚¹ã‚±ä¾é ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ
            if suggested_time.date() == start_time.date():
                message = f"\nğŸ•’ åŒã˜æ—¥ã®{suggested_time.strftime('%H:%M')}ã‹ã‚‰ã§ã‚‚ã‚ˆã‚ã—ã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ"
            else:
                weekday_jp = ["æœˆ", "ç«", "æ°´", "æœ¨", "é‡‘", "åœŸ", "æ—¥"][suggested_time.weekday()]
                message = f"\nğŸ“† {suggested_time.strftime('%mæœˆ%dæ—¥')}({weekday_jp})ã®{suggested_time.strftime('%H:%M')}ã‹ã‚‰ã§ã‚‚ã‚ˆã‚ã—ã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ"

            choice = input(f"{message} ").strip()

            # OpenAIã‚’ä½¿ã£ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è‡ªç„¶è¨€èªå¿œç­”ã‚’è§£æ
            analysis = analyze_user_response(choice)

            if analysis["is_affirmative"] and analysis["confidence"] > 50:
                print(f"âœ… æ—¥æ™‚å¤‰æ›´æ¡ˆã‚’æ‰¿èªã—ã¾ã—ãŸã€‚")
                start_time = suggested_time
                end_time = suggested_end
                schedule_changed = True  # ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå¤‰æ›´ã•ã‚ŒãŸã“ã¨ã‚’ãƒãƒ¼ã‚¯
                # æ–°ã—ã„æ™‚é–“ã§å†åº¦ç«¶åˆãƒã‚§ãƒƒã‚¯
                regular_conflicts, all_day_conflicts = find_conflicting_events(service, start_time, end_time)
            else:
                print("âŒ äºˆå®šã®è¿½åŠ ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚")
                return None

    # é€šå¸¸ã‚¤ãƒ™ãƒ³ãƒˆã¨ã®ç«¶åˆå‡¦ç†
    if regular_conflicts:
        print("\nâš  **ã“ã®æ™‚é–“å¸¯ã«ã¯ä»¥ä¸‹ã®äºˆå®šã¨é‡è¤‡ã—ã¦ã„ã¾ã™ï¼**")
        for title, c_start, c_end, _ in regular_conflicts:
            print(f"  ğŸ“… {title}ï¼ˆ{c_start.strftime('%Y-%m-%d %H:%M')} ã€œ {c_end.strftime('%H:%M')}ï¼‰")

        suggested_time = find_next_available_time(service, start_time, (end_time - start_time).seconds // 60)
        suggested_end = suggested_time + datetime.timedelta(minutes=(end_time - start_time).seconds // 60)

        # ã‚ˆã‚Šè‡ªç„¶ãªãƒªã‚¹ã‚±ä¾é ¼ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ
        if suggested_time.date() == start_time.date():
            duration_min = (suggested_end - suggested_time).seconds // 60
            message = f"\nğŸ•’ åŒã˜æ—¥ã®{suggested_time.strftime('%H:%M')}ã‹ã‚‰{duration_min}åˆ†é–“ã§ã‚ˆã‚ã—ã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ"
        else:
            weekday_jp = ["æœˆ", "ç«", "æ°´", "æœ¨", "é‡‘", "åœŸ", "æ—¥"][suggested_time.weekday()]
            message = f"\nğŸ“† {suggested_time.strftime('%mæœˆ%dæ—¥')}({weekday_jp})ã®{suggested_time.strftime('%H:%M')}ã‹ã‚‰ã«å¤‰æ›´ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã—ã‚‡ã†ã‹ï¼Ÿ"

        choice = input(f"{message} ").strip()

        # OpenAIã‚’ä½¿ã£ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è‡ªç„¶è¨€èªå¿œç­”ã‚’è§£æ
        analysis = analyze_user_response(choice)

        if analysis["is_affirmative"] and analysis["confidence"] > 50:
            print(f"âœ… æ—¥æ™‚å¤‰æ›´æ¡ˆã‚’æ‰¿èªã—ã¾ã—ãŸã€‚")
            start_time = suggested_time
            end_time = suggested_end
            schedule_changed = True  # ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå¤‰æ›´ã•ã‚ŒãŸã“ã¨ã‚’ãƒãƒ¼ã‚¯
        else:
            print("âŒ äºˆå®šã®è¿½åŠ ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚")
            return None

    # ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã¯ã€å¤‰æ›´å¾Œã®äºˆå®šè©³ç´°ã‚’è¡¨ç¤ºã—ã¦æœ€çµ‚ç¢ºèª
    if schedule_changed:
        print("\nğŸ“… å¤‰æ›´å¾Œã®äºˆå®šè©³ç´°:")
        print(f"  ğŸ· ã‚¿ã‚¤ãƒˆãƒ«: {summary}")
        print(f"  ğŸ“ å ´æ‰€: {location}")
        print(f"  ğŸ“ èª¬æ˜: {description}")

        if is_all_day:
            print(f"  ğŸ“† çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆ: {start_time.strftime('%Y-%m-%d')}")
        else:
            print(f"  â° é–‹å§‹: {start_time.strftime('%Y-%m-%d %H:%M')}")
            print(f"  â³ çµ‚äº†: {end_time.strftime('%Y-%m-%d %H:%M')}")
        
        # å¤‰æ›´å¾Œã®æœ€çµ‚ç¢ºèª
        final_choice = input("\nä¸Šè¨˜ã®å¤‰æ›´ã•ã‚ŒãŸäºˆå®šã‚’è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ (y/n): ").strip().lower()
        if final_choice != 'y':
            print("âŒ äºˆå®šã®è¿½åŠ ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚")
            return None

    # ç¢ºèªãŒæ¸ˆã‚“ã§ã„ãªã„å ´åˆã®ã¿æœ€çµ‚ç¢ºèªã‚’è¡Œã†
    elif not already_confirmed:
        choice = input("\nã“ã®äºˆå®šã‚’è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ (y/n): ").strip().lower()
        if choice != 'y':
            print("âŒ äºˆå®šã®è¿½åŠ ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚")
            return None

    # ã‚¤ãƒ™ãƒ³ãƒˆã®ä½œæˆï¼ˆçµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆå¯¾å¿œï¼‰
    event = {
        'summary': summary,
        'location': location,
        'description': description,
    }

    if is_all_day:
        # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆ
        end_date = (start_time + datetime.timedelta(days=1)).date()  # çµ‚äº†æ—¥ã¯æ¬¡ã®æ—¥
        event['start'] = {
            'date': start_time.strftime('%Y-%m-%d'),
            'timeZone': 'Asia/Tokyo',
        }
        event['end'] = {
            'date': end_date.strftime('%Y-%m-%d'),
            'timeZone': 'Asia/Tokyo',
        }
    else:
        # é€šå¸¸ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆ
        event['start'] = {
            'dateTime': start_time.isoformat(),
            'timeZone': 'Asia/Tokyo',
        }
        event['end'] = {
            'dateTime': end_time.isoformat(),
            'timeZone': 'Asia/Tokyo',
        }

    event['reminders'] = {
        'useDefault': True,
    }

    try:
        event = service.events().insert(calendarId='primary', body=event).execute()
        return event
    except HttpError as error:
        print(f'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {error}')
        return None


def handle_missing_event_info(event_info):
    """ä¸è¶³ã—ã¦ã„ã‚‹äºˆå®šæƒ…å ±ã‚’å¯¾è©±çš„ã«è£œå®Œã™ã‚‹"""
    # æ–‡å­—åˆ—ã‹ã‚‰JSONã‚’è§£æ
    if isinstance(event_info, str):
        try:
            event_info = json.loads(event_info)
        except:
            print("âŒ JSONã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
            event_info = {}

    # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¨­å®š
    if not event_info.get('summary'):
        event_info['summary'] = "äºˆå®š"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ã‚¤ãƒˆãƒ«

    if not event_info.get('date'):
        today = datetime.datetime.now(TZ).strftime("%Y-%m-%d")
        print(f"ğŸ“… æ—¥ä»˜ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ãŸã‚ã€ä»Šæ—¥ï¼ˆ{today}ï¼‰ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
        event_info['date'] = today

    # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã®è¨­å®š
    is_all_day = event_info.get('all_day', False)
    if isinstance(is_all_day, str):
        is_all_day = is_all_day.lower() in ('true', 'yes', '1')
    event_info['all_day'] = is_all_day

    # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã§ãªã„å ´åˆã¯æ™‚é–“è¨­å®š
    if not is_all_day:
        if not event_info.get('time'):
            now = datetime.datetime.now(TZ)
            # 30åˆ†å˜ä½ã«åˆ‡ã‚Šä¸Šã’
            if now.minute >= 30:
                next_hour = (now + datetime.timedelta(hours=1)).replace(minute=0)
            else:
                next_hour = now.replace(minute=30)
            default_time = next_hour.strftime("%H:%M")
            print(f"â° æ™‚é–“ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ãŸã‚ã€{default_time}ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
            event_info['time'] = default_time

        if not event_info.get('duration') or int(event_info.get('duration', 0)) <= 0:
            print("âŒ› æ‰€è¦æ™‚é–“ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ãŸã‚ã€60åˆ†ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")
            event_info['duration'] = 60

    if not event_info.get('location'):
        event_info['location'] = "ã‚ªãƒ•ã‚£ã‚¹"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å ´æ‰€
        print(f"ğŸ“ å ´æ‰€ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„ãŸã‚ã€ã€Œ{event_info['location']}ã€ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚")

    if not event_info.get('description'):
        event_info['description'] = f"{event_info['summary']}ã®äºˆå®š"  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®èª¬æ˜

    return event_info


# ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚°ãƒ©ãƒ 
def main():
    try:
        # OpenAI API ã‚­ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
        setup_openai_api()

        print("ğŸ”„ Google Calendarã‚µãƒ¼ãƒ“ã‚¹ã«æ¥ç¶šä¸­...")
        service = get_calendar_service()
        print("âœ… Google ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ API ã«æ¥ç¶šã—ã¾ã—ãŸï¼")

        # ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®å…¥åŠ›ï¼ˆè‡ªç„¶è¨€èªã§ç›´æ¥å…¥åŠ›ï¼‰
        text = input("ğŸ“„ äºˆå®šã®è©³ç´°ã‚’è‡ªç”±ã«å…¥åŠ›ã—ã¦ãã ã•ã„: ").strip()
        print("ğŸ§  OpenAIã§äºˆå®šæƒ…å ±ã‚’è§£æä¸­...")
        event_info_json = extract_event_info(text)

        if event_info_json:
            print(f"ğŸ“Š æŠ½å‡ºã•ã‚ŒãŸäºˆå®šæƒ…å ±: {event_info_json}")
            event_info = json.loads(event_info_json)

            # ä¸è¶³ã—ã¦ã„ã‚‹æƒ…å ±ã‚’è‡ªå‹•è£œå®Œ
            event_info = handle_missing_event_info(event_info)

            # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
            is_all_day = event_info.get('all_day', False)

            if is_all_day:
                # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆ
                start_date = datetime.datetime.strptime(event_info['date'], "%Y-%m-%d")
                start = TZ.localize(start_date)
                end = start  # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã€APIã§è‡ªå‹•çš„ã«æ¬¡ã®æ—¥ãŒçµ‚äº†æ—¥ã«ãªã‚‹

                # ã‚¤ãƒ™ãƒ³ãƒˆè¿½åŠ 
                created_event = add_event(
                    service,
                    event_info['summary'],
                    event_info['location'],
                    event_info['description'],
                    start,
                    end,
                    is_all_day=True
                )
            else:
                # é€šå¸¸ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆ
                try:
                    start = datetime.datetime.strptime(f"{event_info['date']} {event_info['time']}", "%Y-%m-%d %H:%M")
                    start = TZ.localize(start)
                    duration = int(event_info['duration'])
                    end = start + datetime.timedelta(minutes=duration)

                    # ã‚¤ãƒ™ãƒ³ãƒˆè¿½åŠ 
                    created_event = add_event(
                        service,
                        event_info['summary'],
                        event_info['location'],
                        event_info['description'],
                        start,
                        end,
                        is_all_day=False
                    )
                except Exception as e:
                    print(f"âŒ æ—¥æ™‚ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
                    print("æ‰‹å‹•ã§æƒ…å ±ã‚’å…¥åŠ›ã—ã¾ã™ã€‚")
                    manual_input(service)
                    return

            if created_event:
                print(f"âœ… ã‚¤ãƒ™ãƒ³ãƒˆãŒä½œæˆã•ã‚Œã¾ã—ãŸ: {created_event['htmlLink']}")
        else:
            print("âŒ äºˆå®šæƒ…å ±ã®æŠ½å‡ºã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§å…¥åŠ›ã—ã¾ã™ã€‚")
            manual_input(service)

    except Exception as e:
        print(f"âŒ äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")


def manual_input(service):
    """æ‰‹å‹•ã§äºˆå®šæƒ…å ±ã‚’å…¥åŠ›ã™ã‚‹"""
    date_str = input("ğŸ“… äºˆå®šã®æ—¥ä»˜ã‚’ YYYY-MM-DD å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„: ")

    # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã‹ã©ã†ã‹ã‚’ç¢ºèª
    is_all_day = input("ğŸ“† ã“ã®äºˆå®šã¯çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã§ã™ã‹ï¼Ÿ (y/n): ").strip().lower() == 'y'

    if is_all_day:
        # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆ
        start = datetime.datetime.strptime(date_str, "%Y-%m-%d")
        start = TZ.localize(start)
        end = start  # çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã€APIã§è‡ªå‹•çš„ã«æ¬¡ã®æ—¥ãŒçµ‚äº†æ—¥ã«ãªã‚‹
    else:
        # é€šå¸¸ã‚¤ãƒ™ãƒ³ãƒˆ
        time_str = input("â° äºˆå®šã®é–‹å§‹æ™‚é–“ã‚’ HH:MM å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„: ")
        start = datetime.datetime.strptime(date_str + " " + time_str, "%Y-%m-%d %H:%M")
        start = TZ.localize(start)

        duration = int(input("âŒ› äºˆå®šã®é•·ã•ï¼ˆåˆ†å˜ä½ï¼‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„: "))
        end = start + datetime.timedelta(minutes=duration)

    event_summary = input("ğŸ· äºˆå®šã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„: ") or "ä¼šè­°"
    event_location = input("ğŸ“ äºˆå®šã®å ´æ‰€ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„: ") or "ã‚ªãƒ•ã‚£ã‚¹"
    event_description = input("ğŸ“ äºˆå®šã®èª¬æ˜ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„: ") or "è‡ªå‹•è¿½åŠ ã•ã‚ŒãŸäºˆå®š"

    created_event = add_event(
        service,
        event_summary,
        event_location,
        event_description,
        start,
        end,
        is_all_day=is_all_day
    )

    if created_event:
        print(f"âœ… ã‚¤ãƒ™ãƒ³ãƒˆãŒä½œæˆã•ã‚Œã¾ã—ãŸ: {created_event['htmlLink']}")


if __name__ == "__main__":
    main()